<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap 面试题摘录]]></title>
    <url>%2F2017%2F07%2F12%2FHashMap-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。 “当两个对象的hashcode相同会发生什么？”因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用LinkedList存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在LinkedList中（JDK1.8 中已经可以采用红黑树）。(当向 HashMap 中添加 key-value 对，由其 key 的 hashCode() 返回值决定该 key-value 对（就是 Entry 对象）的存储位置。当两个 Entry 对象的 key 的 hashCode() 返回值相同时，将由 key 通过 eqauls() 比较值决定是采用覆盖行为（返回 true），还是产生 Entry 链（返回 false）。) “如果两个键的hashcode相同，你如何获取值对象？”当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。如果有两个值对象储存在同一个bucket，将会遍历LinkedList直到找到值对象。找到bucket位置之后，会调用keys.equals()方法去找到LinkedList中正确的节点，最终找到要找的值对象。(当程序通过 key 取出对应 value 时，系统只要先计算出该 key 的 hashCode() 返回值，在根据该 hashCode 返回值找出该 key 在 table 数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value 即可。) 上面的描述（会调用keys.equals()方法去找到LinkedList中正确的节点），实际上在这之前还会通过==先进行判断。这里看源码(jdk 1.8)1234567891011121314151617181920212223242526public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;..........final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //这里判断根据hash取到对象不为空 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) //这里是本题的关键：当hash相等时先通过`==`判断是否为真，否则再通过`equals`判断 return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; “如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 “你了解重新调整HashMap大小存在什么问题吗？”当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在LinkedList中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在LinkedList的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？ ConcurrentHashMap和Hashtable的区别Hashtable和ConcurrentHashMap有什么分别呢？它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。 HashMap不是线程安全的，你怎么理解线程安全。原理是什么？几种方式避免线程安全的问题。线程安全就是多个线程去访问的时候，会对对象造成不是预期的结果，一般要加锁才能线程安全。//TODO 参考 http://www.cnblogs.com/zywu/p/5753736.html Java基础系列之(三) - HashMap深度分析 http://www.cnblogs.com/wuhuangdi/p/4175991.html]]></content>
      <categories>
        <category>面试题</category>
        <category>Java</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap 源码阅读]]></title>
    <url>%2F2017%2F07%2F12%2FHashMap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[版本 Oracle 1.8 笔记提纲计划 数据结构分析 HashMap特点 类 目标理解了以下问题，本篇笔记的目的就达到了 哈希基本原理？（答：散列表、hash碰撞、链表、红黑树） hashmap查询的时间复杂度， 影响因素和原理？ （答：最好O（1），最差O（n）， 如果是红黑O（logn）） resize如何实现的， 记住已经没有rehash了！！！（答：拉链entry根据高位bit散列到当前位置i和size+i位置） get put 的过程。 数据结构HashMap 基本就是哈希表，其底层实现就是围绕哈希表展开的，源码阅读也是在理解了哈希表的前提下进行为上策。哈希表的理念就是Key值与存储位置有固定的对应关系，而这种关系需要通过某中函数来构造出来，这个函数就是哈希函数。 哈希函数有6种实现： 摘录自百度百科–哈希表 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H&gt;(key）中没有值了，就放进去。 数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很&gt;大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。 平方取中法：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。 随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p&lt;=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。 除留余数法最常用，也是JavaHashMap使用的方法，有关哈希冲突参考另一篇笔记 哈希冲突处理 http://www.idiary.cc/2017/07/11/Hash-%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/。其中链地址的处理方法正式HashMap处理冲突的基本方法。 下图是经典的hashtable结构,JDK 1.8 中链表也可以由红黑树代替。1.8中的结构(参考：http://www.cnblogs.com/leesf456/p/5242233.html) HashMap 类总览首先看两段注释文档123456789101112/** * This map usually acts as a binned (bucketed) hash table, but * when bins get too large, they are transformed into bins of * TreeNodes, each structured similarly to those in * java.util.TreeMap. Most methods try to use normal bins, but * relay to TreeNode methods when applicable (simply by checking * instanceof a node). Bins of TreeNodes may be traversed and * used like any others, but additionally support faster lookup * when overpopulated. However, since the vast majority of bins in * normal use are not overpopulated, checking for existence of * tree bins may be delayed in the course of table methods. */ 其中but when bins get too large, they are transformed into bins of TreeNodes这句说明了当bin过大时就会采用红黑树进行存储。12345678910111213141516171819202122/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64; 上面这段指明了链表在大于8的情况下会使用红黑树，在小于6的情况下重新使用链表和转化为红黑树对应的table的最小大小（64）。 HashMap 类图 类属性说明1234567891011121314151617181920212223242526public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 默认的初始容量是16，必须是2的幂 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂 transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 填充因子 final float loadFactor;&#125; 函数详解构造函数HashMap一共提供了四个构造函数。1234567/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; 12345678910/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; 123456789101112131415161718192021/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; 12345678910111213/** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 这里着重看下HashMap(int initialCapacity, float loadFactor)函数中的tableSizeFor(initialCapacity)。注释翻译过来的意思就是返回大于cap的最小二的幂数，这个函数的目的就是通过无符号右移动操作先取到比最小幂小1的数（后面连续几个零的二进制的数）。至于为何在开始的时候减一是因为在假设cap已经是二的幂数了，这个时候就是得到cap2倍的幂，更好的解释参见HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）。123456789101112/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 最后一个构造函数是把一个已有的Map对象最为参数，其中主要是调用putMapEntries方法，这个函数中最后是调用了putVal,这个方法在下面介绍。1234567891011121314151617181920212223242526/** * Implements Map.putAll and Map constructor * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; PUT有了对象，就要开始往里面放数据，现在就看下put这个方法。123456789101112131415/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 这个方法只是putVal方法的封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果原来的table为空则resize n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) //对应的位置中没有值，则直接放进去 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //如果hash值相同、key相同（equals判断）则进行更新操作 e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //hash冲突处理 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //如果为当前链表的最后一个元素则直接将新元素放到最后 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //超过转为黑红树的上限时转换为黑红树 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) //链表中有hash值相同、key相同（equals判断）则进行更新操作 break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 这里取得对象在table中索引的代码就是i = (n - 1) &amp; hash，这个实际上就是取模运算n%hash，这里为什么采用前一种方法，看一下说明 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。https://zhuanlan.zhihu.com/p/21673805 上面的源码中当table为null或长度为0时需要重新初始化表格n = (tab = resize()).length;，看下resize方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. 初始化或者翻倍table大小，当原始table为空时使用threshold中存储的值初始化table。 * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 超过最大值就不再扩充了 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; //容量扩展到原来的两倍 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold // 临界值扩展到原来的两倍 &#125; else if (oldThr &gt; 0) //当原来的table长度为0时，并且指定了初始容量（HashMap(int initialCapacity, float loadFactor)），进行到这里 newCap = oldThr; else &#123; // 没有指定初始容量时采用默认 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; //索引为低位的元素 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; //索引为高位的元素 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 方法的文档说明中有这样一句话 Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table. 是说，因为使用的是2的幂数作为扩展的方式，这里就出现了一种情况 旧table中的元素对应（重新进行hash后）到新table中的索引位置必然在原位置或2的幂的位移（移动旧table的长度） 经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。https://zhuanlan.zhihu.com/p/21673805 put的总体流程可参考下图http://idiary.oss-cn-zhangjiakou.aliyuncs.com/images/2017-07-12–HashMap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/hashmap-put.jpg 参考 哈希冲突处理 http://www.idiary.cc/2017/07/11/Hash-%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/ HashMap面试问题http://blog.csdn.net/song19890528/article/details/16891015 【集合框架】JDK1.8源码分析之HashMap（一） http://www.cnblogs.com/leesf456/p/5242233.html HashMap源码分析（JDK1.8）- 你该知道的都在这里了 http://blog.csdn.net/brycegao321/article/details/52527236 Java基础系列之(三) - HashMap深度分析 http://www.cnblogs.com/wuhuangdi/p/4175991.html HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四） Java8系列之重新认识HashMap]]></content>
      <categories>
        <category>Java</category>
        <category>JDK 1.8 源码阅读</category>
        <category>集合</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK 1.8</tag>
        <tag>源码阅读</tag>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash 冲突处理]]></title>
    <url>%2F2017%2F07%2F11%2FHash-%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是哈希表 严蔚敏 《数据结构（C语言版）》 截图 哈希表就是依据 关键字可以根据一定的算法（哈希函数）映射到表中的特定位置 的思想建立的表。因此哈希表最大的特点就是可以根据f(K)函数得到其在数组中的索引。 Hash 冲突在计算hash地址的过程中会出现对于不同的关键字出现相同的哈希地址的情况，即key1 ≠ key2，但是f(key1) = f(key2)，这种情况就是Hash 冲突。具有相同关键字的key1和key2称之为同义词。通过优化哈希函数可以减少这种冲突的情况（如：均衡哈希函数），但是在通用条件下，考虑到于表格的长度有限及关键值（数据）的无限，这种冲突是不可避免的，所以就需要处理冲突。 冲突处理冲突处理分为以下四种方式： 开放地址 线性探测再散列 二次探测再散列 伪随机探测再散列 再哈希 链地址 建立公共溢出区 开放地址开放地址法处理冲突的基本原则就是出现冲突后按照一定算法查找一个空位置存放。公式：Hi为计算出的地址，H(key)为哈希函数，di为增量。其中di的三种获取方式既是上面提到的开放地址法的三种分类（线性探测再散列、二次探测再散列、伪随机探测再散列）。 线性探索再散列即依次向后查找。 二次探索再散列即依次向前后查找，增量为1、2、3的二次方。 伪随机探测再散列伪随机，顾名思义就是随机产生一个增量位移。 例子贴一个《数据结构》中的列子 再哈希法再哈希法，就是出现冲突后采用其他的哈希函数计算，直到不再冲突为止。RHi为不同的哈希函数。 链地址法链接地址法不同与前两种方法，他是在出现冲突的地方存储一个链表，所有的同义词记录都存在其中。形象点说就行像是在出现冲突的地方直接把后续的值摞上去。 例子 建立公共溢出区大概的意思就是对冲突的关键字新建数组进行存储（不是很明确）。 总结这次的Hash冲突处理总结，是源于Java HashMap 源码的阅读，其就是采用了链地址的方式处理的冲突。 参考《数据结构（C语言版）》 严蔚敏 —- Hash表（251）一篇不错的博客 http://blog.csdn.net/qq_27093465/article/details/52269862]]></content>
      <categories>
        <category>数据结构</category>
        <category>HashTable</category>
        <category>冲突处理</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>HashMap 源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA Ubuntu 中文乱码]]></title>
    <url>%2F2017%2F07%2F06%2FIDEA-Ubuntu-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[IDEA有分很多种乱码，菜单栏乱码，console输出中文乱码，代码乱码等等，以下提供一些解决方案。 设置里面的快捷键设置keymap出现中文，或者中文乱码原因：IDEA里面的jdk选择的是本地的JDK，而JDK1.5以上的版本是由多国语言的，会选择操作系统的本地语言，所以编译的提示就会变成中文。解决方案在 IntelliJ IDEA 2016.1\bin\idea64.exe.vmoptions 或 IntelliJ IDEA 2016.1\bin\idea.exe.vmoptions （根据你使用的版本决定）添加如下内容：12-Duser.country=EN-Duser.language=us Console 输出乱码解决方案：在 IntelliJ IDEA 2016.1\bin\idea64.exe.vmoptions 或 IntelliJ IDEA 2016.1\bin\idea.exe.vmoptions 添加:1-Dfile.encoding=UTF-8 菜单乱码原因:字体不支持中文的显示，在idea中，默认的是ubuntu字体，该字体并不支持中文显示，选择一个支持的字体 如simsum 参考http://blog.csdn.net/u013361445/article/details/51113692]]></content>
      <categories>
        <category>Java</category>
        <category>Tools</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>IDEA</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
</search>